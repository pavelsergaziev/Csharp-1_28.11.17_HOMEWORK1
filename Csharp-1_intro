//TODO: 98-я строчка, дописать из лекции

//подключение различных сторонних пространств имён
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace lesson1 //это название проекта, "пространство имён", по нему можно подключать данный проект к другому посредством using
                  //можно внутрь вложить ещё namespace,так и получаются вышеприцепленые System.Collections.Generic и т.п. (каждое название после точки - вложенный namespace)
{

    //точно так же можно добавить сюда using static Console (и можно будет сразу писать ReadLine и WriteLine и т.п.)
    //или вынести наверх using static System.Console;
    //и наоборот, если выкинуть сверху using System, то придётся для вывода текста в консоль писать System.Console.WriteLine()

    class Program
    {
        static void Main(string[] args) // Точка входа. если аргументов у нас нет, можно всё, что в скобках, удалить
        {
            /* 
              такие комменты ставить не рекомендуется,
              потому что можно их понаставить по всей программе, а потом хуй найдёшь

            но иногда можно юзать, чтобы в длинной строке закомментировать кусочек в середине

             фыв
                 фывфв
                 фывфыв
             */




            //порядка определения классов внутри программы нет.
            //можно писать до точки входа, можно после,
            //но по негласному правилу каждый класс выносится в отдельный cs-файл

            //ПЕРЕМЕННЫЕ

            //Переменная - это контейнердля хранения данных, каждой переменной задаётся тип данных, которые она может хранить.
            //Типов данных - овердохуя.
            //Переменные лучше инициализировать сразу (т.е. присвоить новой переменной какое-л значение)

            int i = 0;//целое число, занимает 32 бита памяти
            float aa = 0.1f;//число с плавающей запятой, тоже 32 бита
            double bb = 0.2;//число с плавающей запятой, 64 бита (т.е. в два раза больше флоата, поэтому дабл)
            decimal cc = 0.3m;//десятичный тип, обычно для ведения финансовых расчётов, 128 бит

            var aaa = 10;//неявное объявление переменной. автоматом определяет тип после инициализации. менять тип переменной по ходу
                         //для чего нужен var - есть очень навороченные типы (таки их овердохуя), которые нафиг определять, пусть оно само


           
            char ch1 = 'z';//символ
            char ch2 = '\x0041';//так обозначается символ с указанным кодом
            Console.WriteLine(ch2);

            string str1 = "asdasd";//строка - ссылка на массив символов charю Строка - это, по сути, объект System.String
            System.String str2 = "asdadas";
            String str3 = "aasdd";//поскольку using System у нас вынесено в подключение пространств имён, то можно и так

            

            //Приведение типов
            int sss = Convert.ToInt32(aa);//Convert пытается преобразовать любой тип в указанный (базовые типы среди тех, которые можно указать, есть практически все). i = (int)value - другая форма записи Convert.ToInt32;
            cc = (decimal) i;
            i = int.Parse("123");//int.Parse() пытается преобразовать string в int. По слухам, Parse работает на несколько тысячных долей секунды быстрее;


            //запаковка и распаковка. лучше не юзать, ибо очень ресурсоёмко. С выхо



            //эскейп-последовательности, или управляющие последовательности
            // \n - новая строка, \r - возврат в начало строки, \t - табуляция, \' - одинарная кавычка, \" - двойная кавычка, \\ - обратная косая черта
            Console.Write(" Привет \n привет \n привет \n \"привет\" \n");


            //Может понадобиться преобразовать различные типы данных в строку, для вывода, например.
            int a = 12;
            double b = 5;
            Console.WriteLine("Сумма из " + a + " и " + b + " будет равняться " + (a + b));
            //такой автоматический способ, однако, крайне ресурсоёмкий, и лучше его не использовать в реальных приложениях.
            //грубо говоря, тут создаются объекты ДОПИСАТЬ

            //Лучше использовать для этой цели форматированный вывод
            Console.WriteLine("{0} / {1} = {2}", a, b, a / b);

            //а если выводить надо не в консоли, то закидываем в стринг вот так
            string formattedString1 = String.Format("{0} / {1} = {2}", a, b, a / b);

            //интерполяция. новая фишка, в юнити пока не включена
            string formattedString2 = $"{a} - это число, {b} - второе число, а их разность равна {a - b}";

            //спецификации форматирования из списка в методичке (currency, decimal и т.п.) лучше не использовать, может криво пойти
            //но например
            Console.WriteLine("Число с фиксированной точкой - {0:F2}", 1.00000);




            try
            {
                formattedString1 = String.Format("{0} / {1} = {2}", a, b, a / b);
            }
            catch
            {

                Console.WriteLine("корявая строка");
            }



            //вызываем методы (их определение см. ниже)
            WriteSomeShit();
            WriteSomeShit("траляля");
            Console.WriteLine(SumOfNumbers(5,15));
            Console.WriteLine(SumOfNumbers(5, 1, 234, 54, 44, 4));

        }
        //методы определяются в пространстве класса.
        //Если они потом вызываются из другого метода в том же классе (напр, из Main),
        //то разницы, выше они ниже того метода, из которого вызываются, нету.

        static void WriteSomeShit()//без возвращения каких-либо данных (для этого определяем тип как void) и без параметров
        {
            Console.WriteLine("Some shit");
        }

        static void WriteSomeShit(string str1)//с параметрами. ну и перегрузка заодно (метод с уже существующим именем, вызываться будет тот, который подходит по задаваемым в его вызове параметрам)
        {
            Console.WriteLine(str1);
        }

        static int SumOfNumbers(int a, int b)//возвращает значение типа int
        {
            return a + b;
        }

        static int SumOfNumbers(params int[] number)//params позволяет передавать методу любое число аргументов, они добавляются в создаваемый при этом массив
        {

            int sum = 0;

            for (int i = 0; i < number.Length; i++)
            {
                sum = sum + number[i];
            }
            return sum;
        }
    }
}
