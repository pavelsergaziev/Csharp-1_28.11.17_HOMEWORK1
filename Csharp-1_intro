//TODO: строка 200, спросить про try-catch, ибо ошибка выдаётся на компиляции, и программа не запускается.

//подключение различных сторонних пространств имён
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace lesson1 //это название проекта, "пространство имён", по нему можно подключать данный проект к другому посредством using
                  //можно внутрь вложить ещё namespace,так и получаются вышеприцепленые System.Collections.Generic и т.п. (каждое название после точки - вложенный namespace)
{

    //точно так же можно добавить сюда using static Console (и можно будет сразу писать ReadLine и WriteLine и т.п.)
    //или вынести наверх using static System.Console;
    //и наоборот, если выкинуть сверху using System, то придётся для вывода текста в консоль писать System.Console.WriteLine()

    class Program
    {
        static void Main(string[] args) // Точка входа. если аргументов у нас нет, можно всё, что в скобках, удалить
        {
            /* 
              такие комменты ставить не рекомендуется,
              потому что можно их понаставить по всей программе, а потом хуй найдёшь

            но иногда можно юзать, чтобы в длинной строке закомментировать кусочек в середине

             фыв
                 фывфв
                 фывфыв
             */




            //порядка определения классов внутри программы нет.
            //можно писать до точки входа, можно после,
            //но по негласному правилу каждый класс выносится в отдельный cs-файл

            //ПЕРЕМЕННЫЕ

            //Переменная - это контейнер для хранения данных, каждой переменной задаётся тип данных, которые она может хранить.
            //Типов данных - овердохуя.
            //Переменные лучше инициализировать сразу (т.е. присвоить новой переменной какое-л значение)

            int i = 0;//целое число, занимает 32 бита памяти
            float aa = 0.1f;//вещественное число с плавающей запятой, тоже 32 бита
            double bb = 0.7;//вещественное число с плавающей запятой, 64 бита (т.е. в два раза больше флоата, поэтому дабл). Чаще всего будем пользовать этот тип.
            decimal cc = 0.3m;//десятичный тип, обычно для ведения финансовых расчётов, 128 бит
                     
            char ch1 = 'z';//символ
            char ch2 = '\x0041';//так обозначается символ с указанным кодом
            Console.WriteLine(ch2);

            string str1 = "asdasd";//строка - ссылка на массив символов charю Строка - это, по сути, объект System.String
            System.String str2 = "asdadas";
            String str3 = "aasdd";//поскольку using System у нас вынесено в подключение пространств имён, то можно и так


            var aaa = 10;//неявное объявление переменной. автоматом определяет тип после инициализации. менять тип переменной после инициализации нельзя.
                         //поскольку мы инициализируем сразу с объявлением, проблем нет. В 7-й версии шарпа даже рекомендуется в большинстве случаев использовать именно var
                         //для чего нужен var - для ООП, когда не очень понятно заранее, какого типа объект мы получаем,
                         //плюс есть очень навороченные типы (таки их овердохуя), которые нафиг определять, пусть оно само
                         //пример
            int[] arr = { 1, 2, 3, 4, 5, 6 };
            var subArr = arr.Where(e => e > 3);//это выборка из массива, вытаскивающая элементы, которые больше трёх
            Console.WriteLine(subArr.GetType());//а это мы выводим тип данных, некий частный вариант типа Enumerable. Такое определять явно - задалбаца, да и зачем


            //Приведение типов

            //неявная типизация
            cc = i;//тут у нас инт сам привёлся к decimal.
            //int занимает меньше места, поэтому все сохранённые в этой переменной данные можно без потерь переконвертировать в переменную того типа, которая занимает больше места
            //а вот обратно уже не так просто,
            //i = bb; выдаст ошибку

            //Тут необходимо явное приведение
            i = Convert.ToInt32(bb);//Тут в итоге получится отброс дробной части с округлением

            int sss = Convert.ToInt32(aa);//Convert пытается преобразовать любой тип в указанный (базовые типы среди тех, которые можно указать, есть практически все). i = (int)value - другая форма записи Convert.ToInt32;
            cc = (decimal) i;
            i = int.Parse("123");//int.Parse() пытается преобразовать string в int. По слухам, Parse работает на несколько тысячных долей секунды быстрее;


            //Упаковка и распаковка. лучше не юзать, ибо очень ресурсоёмко. С появлением т.н. обобщённых типов от этой вещи отказались, это в большинстве случаев считается устаревшей штукой.
            //object - это тип, базовый для всех остальных типов, и он может выступать как бы в качестве переменной любого типа
            object o = 1.1;
            Console.WriteLine(o.GetType());

            o = str1;
            Console.WriteLine(o.GetType());

            o = new Random();
            Console.WriteLine(o.GetType());

            o = 12;
            Console.WriteLine(o.GetType());
            //вот это 'object 0 = 1;' называется "мы упаковали целое число в объект 'о'"
            //o = str1; упаковали строковую переменную в объект 'о', и т.п.
            //С запакованными таким образом данными особо никаких операций не провернёшь, потому что тип их снаружи не виден,
            //т.е. операция вида 'o + o' выдаст ошибку, ибо непонятно, что делать - складывать, конкатенировать или ещё что.
            //Поэтому для работы с этими запакованными данными нужно их сначала распаковать обратно:
            Console.WriteLine(Convert.ToInt32(o) + Convert.ToInt32(o));


            //динамический тип - хитрая штука, при использовании такой переменной в различных операциях компилятор не проверяет его тип. А то, что в dynamic содержится, к выполнению программы переносится в object
            //может помочь, когда нужно написать какой-то код с неизвестным заранее типом данных, но с обязательными операциями, а компилятор выдаёт ошибку про приведение типов
            //например, позволяет обращаться к полям объектов, не зная вообще об их компоновке и структуре
            dynamic dyn = 99;



            //СУФФИКСЫ
            //В данном курсе будут обычно инты и даблы, где суффиксы не нужны но в юнити обязательно, т.к. там сплошные флоаты
            aa = 12.999f;//f - суффикс, указывающий, что это флоат

            //L,l - длинное целое (long)
            //U,u - беззнаковое целое (unsigned)
            //F,f - вещественное с одинарной точностью (float)
            //D,d - вещественное с двойной точностью (long) - по умолчанию сисло с запятой будет дабл, так что можно без суффикса
            //M,m - десятичное (decimal)


            //Чутка про перегрузку операций (деление для целых и для чисел с запятой)
            int num1 = 14;
            int num2 = 5;
            Console.WriteLine(num1 / num2);//целочисленное деление с отбрасыванием остатка
            Console.WriteLine(num1 % num2);//остаток от деления
            Console.WriteLine((float)num1 / (float)num2);//а это вроде как тот же синтаксис, т.е. как бы та же операция, но во вводимых параметрах другой тип данных, поэтому операция другая
            //т.е. это перегрузка операций, примерно так же, как и перегрузка методов


            //Чутка про операции со строками

            //эскейп-последовательности, или управляющие последовательности
            //   \n - новая строка
            //   \r - возврат в начало строки
            //   \t - табуляция
            //   \' - одинарная кавычка
            //   \" - двойная кавычка
            //   \\ - обратная косая черта
            Console.Write(" Привет \n привет \n привет \n \"привет\" \n");
            
            //Может понадобиться преобразовать различные типы данных в строку, для вывода, например.
            int a = 12;
            double b = 5;
            Console.WriteLine("Сумма из " + a + " и " + b + " будет равняться " + (a + b));
            //такой автоматический способ, однако, крайне ресурсоёмкий, и лучше его не использовать в реальных приложениях.
            //Оно работает только в консоли, плюс на самом деле это не совсем преобразование в строку.
            //грубо говоря, тут несколько раз производится запаковка и распаковка с использованием object, а в итоге выводится в стринг... 

            //Лучше использовать для этой цели форматированный вывод,
            //правда, в таком виде он работает только при выводе в консоль
            Console.WriteLine("{0} / {1} = {2}", a, b, a / b);
            
            //а если выводить надо не в консоли, то закидываем в стринг вот так
            string formattedString1 = String.Format("{0} / {1} = {2}", a, b, a / b);

            //и к номерам параметров можно дописывать разный вид форматирования
            //, но, опять же, если это делать не в консоли, обычно это достигается другими способами
            Console.WriteLine("ого-го {0,10} / {1} = {2}", a, b, a / b);//тут будет отступ в десять символов                       
            Console.WriteLine("Число с фиксированной точкой - {0:#.##}", 1.12345);//выдаст только два знака после запятой (но если там в конце нули, их не покажет)

            //спецификации форматирования из списка в методичке (currency, decimal и т.п.) лучше не использовать, ибо это не всегда хорошо работает
            //но так чисто в качестве примера
            Console.WriteLine("Число с фиксированной точкой - {0:F2}", 1.00000);//выдаст только два нуля после запятой


            //интерполяция. новая фишка, в юнити пока не включена
            Console.WriteLine($"{a} - это число, {b} - второе число, а их разность равна {a - b}");

            //ну и дополнительные фишки форматирования тут тоже работают
            Console.WriteLine($"{a, 5} - это число, {b} - второе число, а их разность равна {a - b}");

            //текст с форматированием "как написано", тут все спецсимволы и переносы строк воспринимаются как часть текста
            string texxxt = @"sdfsds
asdaad
asdasdadsdaadwadwaads
{a} asdasd
asdasd\r\n\t\asdasdasda";
            Console.Write(texxxt);




            //ЛОГИЧЕСКИЕ ОПЕРАТОРЫ

            // & - И - AND
            // | - ИЛИ - OR
            // ^ - исключающее ИЛИ - XOR
            // && - укороченное И, если первый операнд false, то всё выражение принимает значение false, а второй операнд даже не рассматривается
            // || - укороченное ИЛИ, аналогично предыдущему, но с true
            // ! - НЕ - NOT


            //ОТЛОВ ИСКЛЮЧЕНИЙ
            try
            {
                //formattedString1 = String.Format("{0} / {1} = {2}", texxxt, b, texxxt / b);//вылетает с ошибкой, пофиг на трай-кэтч
                formattedString1 = String.Format("{0} / {1} = {2}", a, b, a / b);
            }
            catch//здесь в скобках можно указать конкретный тип эксепшна
            {

                Console.WriteLine("корявая строка");//здесь мы пишем, как отреагировать на исключение, если оно вылезло
            }



            //вызываем методы (их определение см. ниже)
            WriteSomeShit();
            WriteSomeShit("траляля");
            Console.WriteLine(SumOfNumbers(5,15));
            Console.WriteLine(SumOfNumbers(5, 1, 234, 54, 44, 4));

        }

        //методы определяются в пространстве класса.
        //Если они потом вызываются из другого метода в том же классе (напр, из Main),
        //то разницы, выше они ниже того метода, из которого вызываются, нету.

        //static показывает, что это статический метод класса. про это будет позже.
        //Если вкратце, то Program сам является наполовину статическим классом, поэтому содержащиеся в нём методы могут быть только статическими.
        //Что забавно, если не написать static перед названием метода, ошибки не будет, но вызвать его из программы не получится.

        static void WriteSomeShit()//без возвращения каких-либо данных (для этого определяем тип как void) и без параметров
        {
            Console.WriteLine("Some shit");
        }

        static void WriteSomeShit(string str1)//с параметрами. ну и перегрузка заодно (метод с уже существующим именем, вызываться будет тот, который подходит по задаваемым в его вызове параметрам)
        {
            Console.WriteLine(str1);
        }

        static int SumOfNumbers(int a, int b)//возвращает значение типа int
        {
            return a + b;
        }

        static int SumOfNumbers(params int[] number)//params позволяет передавать методу любое число аргументов, они добавляются в создаваемый при этом массив
        {

            int sum = 0;

            for (int i = 0; i < number.Length; i++)
            {
                sum = sum + number[i];
            }
            return sum;
        }
    }
}

